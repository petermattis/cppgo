// Code generated by cppgo
// DO NOT EDIT!

#ifndef CPPGO_H
#define CPPGO_H

#include <string>
#include <type_traits>
#include <stdint.h>

namespace go {

template <typename T, typename E = void>
struct Type;

template <typename T>
struct Type<T, typename std::enable_if<std::is_class<T>::value>::type> {
  enum { Size = T::Size };
  static T get(const void *data) {
    return T(data);
  }
};

template <typename T>
struct Type<T, typename std::enable_if<std::is_arithmetic<T>::value>::type> {
  enum { Size = sizeof(T) };
  static T get(const void *data) {
    return *reinterpret_cast<const T*>(data);
  }
};

class String {
 struct Header {
   const char *data;
   int64_t size;
 };

 public:
   enum { Size = sizeof(Header) };

 public:
  String(const void *data)
    : hdr_(reinterpret_cast<const Header*>(data)) {
  }

  std::string as_string() const { return std::string(data(), size()); }
  const char* data() const { return hdr_->data; }
  int64_t size() const { return hdr_->size; }

 private:
  const Header* hdr_;
};

template <typename T>
class Pointer {
 public:
  enum { Size = sizeof(void*) };

 public:
  Pointer(const void *data)
    : ptr_(*reinterpret_cast<const uint8_t* const*>(data)),
      elem_(ptr_ != nullptr ? Type<T>::get(ptr_) : T()) {
  }

  const void* get() const {
    return ptr_;
  }
  operator bool() const {
    return get() != nullptr;
  }
  const T operator*() const {
    return elem_;
  }
  const T* operator->() const {
    return &elem_;
  }

 private:
  const void *ptr_;
  const T elem_;
};

template <typename C>
class Iterator {
 public:
  typedef typename C::value_type value_type;
  typedef typename C::reference_type reference_type;
  typedef Iterator<C> self_type;

 public:
  Iterator(const C *c, int index)
    : container_(c),
      index_(index) {
  }
  Iterator(const self_type& x)
    : container_(x.container_),
      index_(x.index_) {
  }

  value_type operator*() const {
    return (*container_)[index_];
  }

  self_type operator++(int) {
    self_type t = *this;
    return ++t;
  }
  self_type& operator++() {
    ++index_;
    return *this;
  }
  self_type operator--(int) {
    self_type t = *this;
    return --*t;
  }
  self_type& operator--() {
    --index_;
    return *this;
  }

  bool operator==(const self_type& other) const {
    return container_ == other.container_ && index_ == other.index_;
  }
  bool operator!=(const self_type& other) const {
    return !(*this == other);
  }

 private:
  const C *container_;
  int index_;
};

template <typename T>
class Slice {
  struct Header {
    const uint8_t *data;
    int64_t size;
    int64_t cap;
  };

 public:
  enum { Size = sizeof(Header) };

  typedef T value_type;
  typedef value_type &reference_type;
  typedef Iterator<Slice<T>> iterator;
  typedef iterator const_iterator;

 public:
  Slice(const void *data)
    : hdr_(reinterpret_cast<const Header*>(data)) {
  }

  value_type operator[](int i) const {
    return Type<T>::get(hdr_->data + i * Type<T>::Size);
  }

  int64_t size() const { return hdr_->size; }

  const_iterator begin() const { return const_iterator(this, 0); }
  const_iterator end() const { return const_iterator(this, size()); }

 private:
  const Header* hdr_;
};

template <typename T, int N>
class Array {
 public:
  enum { Size = N * Type<T>::Size };

  typedef T value_type;
  typedef value_type &reference_type;
  typedef Iterator<Array<T, N>> iterator;
  typedef iterator const_iterator;

 public:
  Array(const void *data)
    : data_(reinterpret_cast<const uint8_t*>(data)) {
  }

  value_type operator[](int i) const {
    return Type<T>::get(data_ + i * Type<T>::Size);
  }

  int64_t size() const { return N; }

  const_iterator begin() const { return const_iterator(this, 0); }
  const_iterator end() const { return const_iterator(this, size()); }

 private:
  const uint8_t *data_;
};

namespace demo {

class Bar {
 public:
  enum { Size = 32 };

 public:
  Bar()
    : data_(nullptr) {
  }
  Bar(const Bar &x)
    : data_(x.data_) {
  }
  Bar(const void *data)
    : data_(reinterpret_cast<const uint8_t*>(data)) {
  }

  int64_t int_val() const {
    return Type<int64_t>::get(data_ + 0);
  }
  double float_val() const {
    return Type<double>::get(data_ + 8);
  }
  String string_val() const {
    return Type<String>::get(data_ + 16);
  }

 private:
  const uint8_t *data_;
};

class Foo {
 public:
  enum { Size = 152 };

 public:
  Foo()
    : data_(nullptr) {
  }
  Foo(const Foo &x)
    : data_(x.data_) {
  }
  Foo(const void *data)
    : data_(reinterpret_cast<const uint8_t*>(data)) {
  }

  Slice<Pointer<demo::Bar>> slice() const {
    return Type<Slice<Pointer<demo::Bar>>>::get(data_ + 0);
  }
  Array<demo::Bar,4> array() const {
    return Type<Array<demo::Bar,4>>::get(data_ + 24);
  }

 private:
  const uint8_t *data_;
};

} // namespace demo

} // namespace go

#endif  // CPPGO_H
